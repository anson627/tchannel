{
  "name": "hexer",
  "version": "1.4.5",
  "description": "Hex Dumper (streaming, sync, and cli)",
  "keywords": [
    "hex",
    "dump",
    "hexdump"
  ],
  "author": {
    "name": "Joshua T Corbin",
    "email": "joshua@wunjo.org"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jcorbin/hexer.git"
  },
  "main": "index.js",
  "homepage": "https://github.com/jcorbin/hexer",
  "bugs": {
    "url": "https://github.com/jcorbin/hexer/issues",
    "email": "joshua@wunjo.org"
  },
  "contributors": [
    {
      "name": "Joshua T Corbin"
    }
  ],
  "bin": {
    "hexer": "./cli.js"
  },
  "dependencies": {
    "ansi-color": "^0.2.1",
    "minimist": "^1.1.0",
    "process": "^0.10.0",
    "readable-stream": "^1.0.33",
    "xtend": "^4.0.0"
  },
  "devDependencies": {
    "coveralls": "^2.10.0",
    "error": "^5.2.0",
    "istanbul": "^0.3.5",
    "itape": "^1.5.0",
    "jshint": "^2.6.0",
    "opn": "^1.0.1",
    "pre-commit": "0.0.9",
    "tape": "^3.4.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/jcorbin/hexer/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "check-cover": "istanbul check-coverage",
    "check-ls": "npm ls 1>/dev/null",
    "cover": "npm run test-cover -s && npm run check-cover -s",
    "lint": "jshint .",
    "test": "npm run check-ls -s && npm run lint -s && npm run cover -s",
    "test-cover": "istanbul cover --report html --print detail -- test/index.js",
    "trace": "itape test/index.js --trace",
    "travis": "npm run cover -s && istanbul report lcov && ((cat coverage/lcov.info | coveralls) || exit 0)",
    "view-cover": "opn ./coverage/index.html"
  },
  "engines": {
    "node": ">= 0.10.x"
  },
  "pre-commit": [
    "check-licence",
    "test"
  ],
  "pre-commit.silent": true,
  "itape": {
    "trace": {
      "debuglog": [
        "hexer"
      ],
      "leakedHandles": {
        "timeout": 5001,
        "debugSockets": true
      },
      "formatStack": true
    }
  },
  "private": false,
  "uber-ngen-version": "5.0.0",
  "readme": "# CLI Usage\n\n```shell\n$ </bin/ls hexer\n```\n\n# API Usage\n\n## Simple mode: buffer -> string\n\nGot as buffer? We can render it:\n\n```javascript\nvar hex = require('hexer');\nconsole.log(hex(someBuffer));\n```\n\n## Simply steram spy mode: in -> hex.Spy (->sink) -> out\n\nWant to see what's going through a stream?\n\n```\nvar hex = require('hexer');\n\nstream\n    .pipe(hex.Spy(process.stdout)) // argument is where to dump to\n    .pipe(somewhere);              // normal output flows through\n```\n\n\n## Simple streaming mode: in -> hex.Transform -> out\n\nGot a stream? We can render it:\n\n```javascript\nvar hex = require('hexer');\nprocess.stdin\n    .pipe(hex.Transform())\n    .pipe(process.stdout);\n```\n\n## Chunked streaming mode: in -> hex.ChunkedTransform -> out\n\nGot a stream? We can render each of its chunks:\n\n```javascript\nvar hex = require('hexer');\nprocess.stdin\n    .pipe(hex.ChunkedTransform())\n    .pipe(process.stdout);\n```\n\n## Advanced chunked streaming mode\n\nFinally you can control the sessionization yourself if that makes sense:\n\n```javascript\nvar hex = require('hexer');\nvar hexer = hex.Transform();\nhexer.pipe(process.stdout);\n\nprocess.stdin.on('data', function onData(chunk) {\n    if (decideToReset(chunk)) {\n        hexer.reset();\n    }\n    hexer.write(chunk);\n});\n```\n\nHowever that example is a bit contrived, a more realistic example would be:\n\n```javascript\nvar hex = require('hexer');\nvar hexer = hex.Transform();\nhexer.pipe(process.stdout);\n\nprocess.stdin.on('data', function onData(chunk) {\n    var i = findBoundary(chunk);\n    while (i > 0) {\n        hexer.write(chunk.slice(0, i));\n        hexer.reset();\n        chunk = chunk.slice(i);\n        i = findBoundary(chunk);\n    }\n    if (chunk.length) {\n        hexer.write(chunk);\n    }\n});\n```\n\n## Options\n\n- prefix: a string that will be printed at the beginning of every line.\n  (default empty string, \"\")\n\n- cols: the number of bytes to display on each line (default 16)\n\n- group: the number of bytes to display adjacently (default 2)\n\n- groupSeparator: a string that appears between byte groups (default one\n  space \" \")\n\n- headSep: a string that appears between the offset column and the byte\n  column (default colon space, \": \")\n\n- divide: a string that appears between the byte value column and the\n  character representation column (default two spaces, \"  \")\n\n- gutter: the minimum width of the gutter, the region on the left that\n  contains the byte offset that each line starts with. (default 0)\n\n- offsetWidth: the minimum number of digits to display in the byte offset\n  column.\n\n- decorateHexen(totalOffset, screenOffset, hexen):\n  A function that has an opportunity to alter the numeric representation of a\n  byte.\n  Decoration is typically used to change the color of the byte based on its\n  position in the stream or position in the line.\n\n- decorateHuman(totalOffset, screenOffset, human, byte):\n  A function that has an opportunity to alter the appearance of a given\n  human-readable representation of a byte.\n  Decoration is typically used to change the color of the byte based on its\n  position in the stream, position on the line, its representation, or its\n  value.\n\n- renderHexen(byte):\n  a function that accepts a byte value and returns a hexen readable, two\n  character representation of that byte.\n  By default, the hexen representation is lower-case zero-padded hex.\n\n- renderHuman(byte):\n  a function that accepts a byte value and returns a human readable, single\n  character representation of that byte.\n  By default, the human representation is the character itself for all\n  printable ASCII characters, and a period \".\" for control characters and\n  EASCII bytes.\n\n- emptyHexen: a two character representation of a non-existant byte at a\n  particular offset for the byte value representation. (default spaces, \"  \")\n\n- emptyHuman: the representation of a non-existant byte in the human readable\n  characters column (default null string, \"\")\n\n- nullHuman: if an entire buffer or stream is empty, the default behavior\n  is to represent it as an empty string or stream.\n  With this option, the empty line will be expressly rendered, with offset\n  zero, empty byte columns, and this string in the human readable characters\n  section.\n\n- colored: if set true, enables ANSI coloring of output\n\n## License and Copyright\n\nCopyright (c) 2015 Joshua T Corbin and contributors.\nAll rights reserved.\nMIT License.\n",
  "readmeFilename": "README.md",
  "_id": "hexer@1.4.5",
  "_shasum": "b7cf15c0db63710a707e00245bb35b1f4f566d2e",
  "_resolved": "http://archive.local.uber.internal/npm/hexer/hexer-1.4.5.tgz",
  "_from": "hexer@>=1.4.5 <2.0.0"
}
